import pandas as pd
from tensorflow.keras.models import load_model
import pkg_resources
import joblib
import ipaddress
import numpy as np

class MalwareClassifier:
    """
    A class for loading a pre-trained neural network model and making predictions on malware data.

    Attributes:
        model_file (str): The file path of the trained neural network model.
        weights_file (str): The file path of the trained model's weights.
        standard_scaler_file (str): The file path of the StandardScaler used for data scaling.
    """

    def __init__(self):
        """
        Initializes the MalwareClassifier object by loading the model and associated files.
        """
        self.model_file = "data/model.h5"
        self.weights_file = "data/weights.h5"
        self.standard_scaler_file = "data/standard_scaler.pkl"
        self.label_encoder_file = "data/label_encoder.pkl"
        self._load_model()

    def _load_model(self):
        """
        Loads the trained neural network model and its weights.
        """
        self.model = load_model(pkg_resources.resource_filename(__package__, self.model_file))
        self.model.load_weights(pkg_resources.resource_filename(__package__, self.weights_file))

    def _scale_data(self, data):
        """
        Scales the input data using the pre-trained StandardScaler.

        Args:
            data (DataFrame): The input data to be scaled.

        Returns:
            DataFrame: The scaled input data.
        """
        scaler = joblib.load(pkg_resources.resource_filename(__package__, self.standard_scaler_file))
        data_scaled = scaler.transform(data)
        return data_scaled

    def _encode_data(self, data):
        """
        Encodes categorical columns in the input data using pre-trained LabelEncoders.

        Args:
            data (DataFrame): The input data to be encoded.
        """
        columns_to_hash = ['id.orig_h', 'id.resp_h']

        for column in columns_to_hash:
            data[column] = data[column].apply(hash)

        categorical_columns = ['proto', 'conn_state', 'history']

        # Apply LabelEncoder to categorical columns
        for column in categorical_columns:
            label_encoder = joblib.load(pkg_resources.resource_filename(__package__, f'data/categorical_label_encoder_{column}.pkl'))
            data[column] = label_encoder.transform(data[column])

    def _validate_input_data(self, data):
        """
        Validates the input data to ensure it contains all required columns and valid values.

        Args:
            data (pandas.DataFrame): The input data to be validated.

        Raises:
            ValueError: If the input data is missing required columns or contains invalid values.
        """
        required_columns = {'id.orig_h', 'id.orig_p', 'id.resp_h', 'id.resp_p', 'proto', 'conn_state', 'history', 'orig_pkts', 'orig_ip_bytes', 'resp_pkts', 'resp_ip_bytes'}

        if data.empty:
            raise ValueError("No data provided")

        missing_columns = required_columns - set(data.columns)
        if missing_columns:
            raise ValueError(f"Missing required columns in input data: {missing_columns}")

        for col_name in data.columns:
            if col_name in {'id.orig_p', 'id.resp_p', 'orig_pkts', 'orig_ip_bytes', 'resp_pkts', 'resp_ip_bytes'}:
                self._validate_numeric_column(col_name, data[col_name])
            elif col_name in {'id.orig_h', 'id.resp_h'}:
                self._validate_ip_address(col_name, data[col_name])

    def _validate_numeric_column(self, col_name, values):
        """
        Validates a numeric column to ensure it contains only non-negative integer values.

        Args:
            col_name (str): The name of the column to validate.
            values (pandas.Series): The values of the column to validate.

        Raises:
            ValueError: If the column value is not a non-negative integer.
        """
        if not values.astype(str).str.isdigit().all():
            raise ValueError(f"Non-integer value found in column {col_name}")

        if (values < 0).any():
            raise ValueError(f"Negative value found in column {col_name}")

    def _validate_ip_address(self, col_name, values):
        """
        Validates an IP address column to ensure it contains valid IP addresses.

        Args:
            col_name (str): The name of the column to validate.
            values (pandas.Series): The values of the column to validate.

        Raises:
            ValueError: If the column value is not a valid IP address.
        """
        for value in values:
            try:
                ipaddress.ip_address(value)
            except ValueError:
                raise ValueError(f"Invalid IP address found in column {col_name}: {value}")

    def _preprocess_data(self, data):
        """
        Preprocesses the input data by encoding categorical columns and scaling numeric columns.

        Args:
            data (list): The input data to be preprocessed.

        Returns:
            DataFrame: The preprocessed input data.
        """
        df = pd.DataFrame(data)
        self._validate_input_data(df)
        self._encode_data(df)
        df_scaled = self._scale_data(df)
        return df_scaled

    def predict(self, data):
        """
        Make predictions on the input data using the pre-trained neural network model.

        Args:
            data (list): The input data to make predictions on.

        Returns:
            list: A list of dictionaries containing the predicted labels and scores for each prediction.
            
        Raises:
            FileNotFoundError: If the label encoder file is not found.
        """
        preprocessed_data = self._preprocess_data(data)
        predictions = self.model.predict(preprocessed_data)
        try:
            label_encoder = joblib.load(pkg_resources.resource_filename(__package__, self.label_encoder_file))
        except FileNotFoundError:
            raise FileNotFoundError("Error loading label encoder file.")
        results = []
        for result in predictions:
            predicted_label_index = np.argmax(result)
            predicted_label = label_encoder.inverse_transform([predicted_label_index])[0]
            scores = {label: '{:.10f}'.format(score) for label, score in zip(label_encoder.classes_, result)}
            results.append({
                "result": predicted_label,
                "scores": scores
            })
        return results